/*  Pawn compiler - Peephole optimizer "sequences" strings (plain
 *                  and compressed formats)
 *
 *  Copyright (c) CompuPhase, 2000-2024
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not
 *  use this file except in compliance with the License. You may obtain a copy
 *  of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  License for the specific language governing permissions and limitations
 *  under the License.
 *
 *  Version: $Id: sc7.sch 7151 2024-03-23 16:08:18Z thiadmer $
 */

/* Special characters in the strings of this file:
 *  %1 to %5    Parameters that are replaced, the parameters should be numerical
 *              (hexadecimal) values (exceptionally, an alphanumeric symbol).
 *  %0          A parameter that is replaced with its packed value (so on a
 *              32-bit system, 00001234 gets replaced by 1234). Packed opcodes
 *              always take a single parameter, which is why %0 is sufficient.
 *  -           In front of a parameter, - means that the parameter is replaced
 *              by the negated value from the source; this token is valid only
 *              in the replacement string.
 *  +           Between two parameters, + means that the parameters are replaced
 *              by the sum; this token is valid only in the replacement string.
 *  ~           In front of a parameter, and optional space, which should precede
 *              an optional variable.
 *  #           In front of a literal value, the expanded hexadecimal version of
 *              that literal value (so #5 becomes 00000005 on a 32-bit system);
 *              this token is valid only in the replacement string.
 */

SC_FUNC int strexpand(char *dest, const unsigned char *source, int maxlen, const unsigned char pairtable[128][2]);

#define SCPACK_TERMINATOR ,     /* end each section with a comma */

#define SCPACK_TABLE sequences_table
/*-*SCPACK start of pair table, do not change or remove this line */
const unsigned char sequences_table[128][2] = {
  {105,32}, {114,128}, {112,129}, {46,130}, {49,33}, {37,132}, {32,37}, {97,100}, {115,104}, {117,136}, {112,137}, {46,115}, {32,133}, {108,111}, {141,135}, {97,108},
  {50,33}, {143,116}, {59,36}, {46,145}, {46,112}, {131,133}, {105,33}, {114,33}, {131,37}, {115,116}, {97,151}, {112,154}, {146,155}, {142,139}, {114,150}, {148,158},
  {46,99}, {110,153}, {111,161}, {99,162}, {152,144}, {48,33}, {135,100}, {147,33}, {134,144}, {112,111}, {169,112}, {138,114}, {112,33}, {120,172}, {101,173}, {146,174},
  {138,159}, {134,165}, {134,51}, {170,167}, {147,140}, {134,49}, {126,37}, {157,164}, {178,33}, {103,33}, {104,185}, {99,186}, {120,187}, {166,114}, {46,135}, {122,101},
  {190,114}, {191,114}, {101,113}, {163,149}, {156,138}, {46,150}, {110,100}, {105,110}, {52,33}, {32,35}, {199,99}, {101,99}, {100,203}, {157,149}, {156,171}, {140,175},
  {114,101}, {208,102}, {53,33}, {166,33}, {108,209}, {142,149}, {189,149}, {194,33}, {136,108}, {138,109}, {134,200}, {134,50}, {106,193}, {105,100}, {115,103}, {115,108},
  {221,120}, {216,160}, {181,168}, {147,168}, {176,183}, {117,198}, {111,229}, {98,230}, {193,111}, {231,115}, {180,183}, {181,219}, {212,139}, {220,140}, {142,164}, {233,184},
  {179,211}, {139,140}, {160,140}, {171,109}, {170,159}, {198,33}, {152,165}, {153,111}, {247,114}, {97,245}, {163,164}, {182,50}, {235,178}, {182,51}, {134,48}
};
/*-*SCPACK end of pair table, do not change or remove this line */

typedef struct {
  const char *find;
  const char *replace;
  short opc,arg;        /* number of opcodes/arguments saved (may be negative!) */
} SEQUENCE;
static const char separator_macro[] = {sOPTIMIZE_MACRO,'\0'};
static const char separator_full[] = {sOPTIMIZE_FULL,'\0'};
static const SEQUENCE sequences_cmp[] = {
  /* A very common sequence in four varieties
   *    load.s.pri %1           load.s.pri %2
   *    push.pri                load.s.alt %1
   *    load.s.pri %2           -
   *    pop.alt                 -
   *    --------------------------------------
   *    load.pri %1             load.s.pri %2
   *    push.pri                load.alt %1
   *    load.s.pri %2           -
   *    pop.alt                 -
   *    --------------------------------------
   *    load.s.pri %1           load.pri %2
   *    push.pri                load.s.alt %1
   *    load.pri %2             -
   *    pop.alt                 -
   *    --------------------------------------
   *    load.pri %1             load.pri %2
   *    push.pri                load.alt %1
   *    load.pri %2             -
   *    pop.alt                 -
   */
  {
    #ifdef SCPACK
      "load.s.pri %1!push.pri!load.s.pri %2!pop.alt!",
      "load.s.pri %2!load.s.alt %1!",
    #else
      "\315\344\263",
      "\267\235\264",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!push.pri!load.s.pri %2!pop.alt!",
      "load.s.pri %2!load.alt %1!",
    #else
      "\325\344\263",
      "\267\216\264",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!push.pri!load.pri %2!pop.alt!",
      "load.pri %2!load.s.alt %1!",
    #else
      "\315\260\356\263",
      "\356\235\264",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!push.pri!load.pri %2!pop.alt!",
      "load.pri %2!load.alt %1!",
    #else
      "\325\260\356\263",
      "\356\216\264",
    #endif
    4-2, 2-2
  },
  /* (#1#) The above also occurs with "addr.pri" (array
   * indexing) as the first line; so that adds 2 cases.
   */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!pop.alt!",
      "addr.alt %1!load.s.pri %2!",
    #else
      "\326\344\263",
      "\275\352",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.pri %2!pop.alt!",
      "addr.alt %1!load.pri %2!",
    #else
      "\326\260\356\263",
      "\275\264\356",
    #endif
    4-2, 2-2
  },
  /* And the same sequence with const.pri as either the first
   * or the second load instruction: four more cases.
   */
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!pop.alt!",
      "load.s.pri %2!const.alt %1!",
    #else
      "\303\344\263",
      "\267\243\264",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.pri %2!pop.alt!",
      "load.pri %2!const.alt %1!",
    #else
      "\303\260\356\263",
      "\356\243\264",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!push.pri!const.pri %2!pop.alt!",
      "const.pri %2!load.s.alt %1!",
    #else
      "\315\260\372\263",
      "\372\235\264",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!push.pri!const.pri %2!pop.alt!",
      "const.pri %2!load.alt %1!",
    #else
      "\325\260\372\263",
      "\372\216\264",
    #endif
    4-2, 2-2
  },
  /* The same as above, but now with "addr.pri" (array
   * indexing) on the first line and const.pri on
   * the second.
   */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!const.pri %2!pop.alt!",
      "addr.alt %1!const.pri %2!",
    #else
      "\326\260\372\263",
      "\275\264\372",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!zero.pri!pop.alt!",
      "addr.alt %1!zero.pri!",
    #else
      "\326\260\350\237\263",
      "\275\264\350\237",
    #endif
    4-2, 1-1
  },
  /* The same as above, but now with "addr.pri" twice
   * (array copying/comparison).
   */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!addr.pri %2!pop.alt!",
      "addr.alt %1!addr.pri %2!",
    #else
      "\326\260\275\244\263",
      "\275\264\275\244",
    #endif
    4-2, 2-2
  },
  /* The same as above when loading two constants (may happen when setting an
   * array element to a constant.
   */
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!const.pri %2!pop.alt!",
      "const.alt %1!const.pri %2!",
    #else
      "\303\260\372\263",
      "\243\264\372",
    #endif
    4-2, 2-2
  },
  /* ??? add references */
  /* Chained relational operators can contain sequences like:
   *    xchg                    load.s.pri %1
   *    push.pri                -
   *    load.s.pri %1           -
   *    pop.alt                 -
   * The above also occurs for "load.pri" and for "const.pri",
   * so add another two cases.
   */
  {
    #ifdef SCPACK
      "xchg!push.pri!load.s.pri %1!pop.alt!",
      "load.s.pri %1!",
    #else
      "\274\260\315\263",
      "\315",
    #endif
    4-1, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!push.pri!load.pri %1!pop.alt!",
      "load.pri %1!",
    #else
      "\274\260\325\263",
      "\325",
    #endif
    4-1, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!push.pri!const.pri %1!pop.alt!",
      "const.pri %1!",
    #else
      "\274\260\303\263",
      "\303",
    #endif
    4-1, 1-1
  },
  /* More optimizations for chained relational operators; the
   * continuation sequences can be simplified if they turn out
   * to be termination sequences:
   *    xchg                    sless       also for sless, sgeq and sleq
   *    sgrtr                   pop.alt
   *    swap.alt                and
   *    and                     ;$exp
   *    pop.alt                 -
   *    ;$exp                   -
   *    --------------------------------------
   *    xchg                    sless       also for sless, sgeq and sleq
   *    sgrtr                   pop.alt
   *    swap.alt                and
   *    and                     jzer %1
   *    pop.alt                 -
   *    jzer %1                 -
   */
  {
    #ifdef SCPACK
      "xchg!sgrtr!swap.alt!and!pop.alt!;$exp!",
      "sless!pop.alt!and!;$exp!",
    #else
      "\274\336rt\227swap\247\371\263\257",
      "\337ess!\263\371\257",
    #endif
    5-3, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sless!swap.alt!and!pop.alt!;$exp!",
      "sgrtr!pop.alt!and!;$exp!",
    #else
      "\274\337ess!swap\247\371\263\257",
      "\336rt\227\263\371\257",
    #endif
    5-3, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sgeq!swap.alt!and!pop.alt!;$exp!",
      "sleq!pop.alt!and!;$exp!",
    #else
      "\274\336\327swap\247\371\263\257",
      "\337\327\263\371\257",
    #endif
    5-3, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sleq!swap.alt!and!pop.alt!;$exp!",
      "sgeq!pop.alt!and!;$exp!",
    #else
      "\274\337\327swap\247\371\263\257",
      "\336\327\263\371\257",
    #endif
    5-3, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sgrtr!swap.alt!and!pop.alt!jzer %1!",
      "sless!pop.alt!and!jzer %1!",
    #else
      "\274\336rt\227swap\247\371\263\355",
      "\337ess!\263\371\355",
    #endif
    5-3, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sless!swap.alt!and!pop.alt!jzer %1!",
      "sgrtr!pop.alt!and!jzer %1!",
    #else
      "\274\337ess!swap\247\371\263\355",
      "\336rt\227\263\371\355",
    #endif
    5-3, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sgeq!swap.alt!and!pop.alt!jzer %1!",
      "sleq!pop.alt!and!jzer %1!",
    #else
      "\274\336\327swap\247\371\263\355",
      "\337\327\263\371\355",
    #endif
    5-3, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sleq!swap.alt!and!pop.alt!jzer %1!",
      "sgeq!pop.alt!and!jzer %1!",
    #else
      "\274\337\327swap\247\371\263\355",
      "\336\327\263\371\355",
    #endif
    5-3, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sgrtr!;$exp!",
      "sless!;$exp!",
    #else
      "\274\336rt\227\257",
      "\337ess!\257",
    #endif
    2-1, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sless!;$exp!",
      "sgrtr!;$exp!",
    #else
      "\274\337ess!\257",
      "\336rt\227\257",
    #endif
    2-1, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sgeq!;$exp!",
      "sleq!;$exp!",
    #else
      "\274\336\327\257",
      "\337\327\257",
    #endif
    2-1, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sleq!;$exp!",
      "sgeq!;$exp!",
    #else
      "\274\337\327\257",
      "\336\327\257",
    #endif
    2-1, 0-0
  },
  /* The entry to chained operators is also opt to optimization
   *    load.s.pri %1           load.s.pri %2
   *    load.s.alt %2           load.s.alt %1
   *    xchg                    -
   *    --------------------------------------
   *    load.s.pri %1           load.pri %2
   *    load.alt %2             load.s.alt %1
   *    xchg                    -
   *    --------------------------------------
   *    load.s.pri %1           const.pri %2
   *    const.alt %2            load.s.alt %1
   *    xchg                    -
   *    --------------------------------------
   * and all permutations...
   */
  {
    #ifdef SCPACK
      "load.s.pri %1!load.s.alt %2!xchg!",
      "load.s.pri %2!load.s.alt %1!",
    #else
      "\315\235\343\274",
      "\267\235\264",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!load.alt %2!xchg!",
      "load.pri %2!load.s.alt %1!",
    #else
      "\315\216\343\274",
      "\356\235\264",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!const.alt %2!xchg!",
      "const.pri %2!load.s.alt %1!",
    #else
      "\315\243\343\274",
      "\372\235\264",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!load.s.alt %2!xchg!",
      "load.s.pri %2!load.alt %1!",
    #else
      "\325\235\343\274",
      "\267\216\264",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!load.alt %2!xchg!",
      "load.pri %2!load.alt %1!",
    #else
      "\325\216\343\274",
      "\356\216\264",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!const.alt %2!xchg!",
      "const.pri %2!load.alt %1!",
    #else
      "\325\243\343\274",
      "\372\216\264",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!load.s.alt %2!xchg!",
      "load.s.pri %2!const.alt %1!",
    #else
      "\303\235\343\274",
      "\267\243\264",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!load.alt %2!xchg!",
      "load.pri %2!const.alt %1!",
    #else
      "\303\216\343\274",
      "\356\243\264",
    #endif
    3-2, 2-2
  },
  /* some sequences where PRI is moved to ALT can be optimized
   * further when considering what follows
   *    xchg                    const.alt %1
   *    const.pri %1            -
   *    xchg                    -
   * (also for load.s.pri and load.pri)
   *    --------------------------------------
   *    lref.pri %1             lref.alt %1
   *    xchg                    [load.pri %2]
   *    [load.pri %2]           -
   * (where [load.pri %2] may also be another operatrion loading PRI)
   */
  {
    #ifdef SCPACK
      "xchg!const.pri %1!xchg!",
      "const.alt %1!",
    #else
      "\274\303\274",
      "\243\264",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!load.pri %1!xchg!",
      "load.alt %1!",
    #else
      "\274\325\274",
      "\216\264",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!load.s.pri %1!xchg!",
      "load.s.alt %1!",
    #else
      "\274\315\274",
      "\235\264",
    #endif
    3-1, 1-1
  },
  /* ----- */
  {
    #ifdef SCPACK
      "lref.pri %1!xchg!load.pri %2!",
      "lref.alt %1!load.pri %2!",
    #else
      "\324\225\274\356",
      "\324\264\356",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "lref.pri %1!xchg!load.s.pri %2!",
      "lref.alt %1!load.s.pri %2!",
    #else
      "\324\225\274\267",
      "\324\352",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "lref.pri %1!xchg!const.pri %2!",
      "lref.alt %1!const.pri %2!",
    #else
      "\324\225\274\372",
      "\324\264\372",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "lref.s.pri %1!xchg!load.pri %2!",
      "lref.s.alt %1!load.pri %2!",
    #else
      "\354\225\274\356",
      "\354\264\356",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "lref.s.pri %1!xchg!load.s.pri %2!",
      "lref.s.alt %1!load.s.pri %2!",
    #else
      "\354\225\274\267",
      "\354\352",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "lref.s.pri %1!xchg!const.pri %2!",
      "lref.s.alt %1!const.pri %2!",
    #else
      "\354\225\274\372",
      "\354\264\372",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "lref.s.pri %1!push.pri!lref.s.pri %2!pop.alt!",
      "lref.s.alt %1!lref.s.pri %2!",
    #else
      "\354\225\260\354\244\263",
      "\354\264\354\244",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "push.pri!lref.s.pri %1!pop.alt!",
      "xchg!lref.s.pri %1!",
    #else
      "\260\354\225\263",
      "\274\354\225",
    #endif
    3-2, 1-1
  },
  /* Useless arithmetic operations, like adding or subtracting zero, or
   * multiplying or dividing by 1. Note that subtraction cases are a slightly more convoluted because these operations are not commutative.
   *    const.alt 0             -
   *    add                     -
   *    --------------------------------------
   *    const.pri 0             load.s.pri %1
   *    load.s.alt %1           -
   *    sub                     -
   *    --------------------------------------
   *    const.pri 0             load.pri %1
   *    load.alt %1             -
   *    sub                     -
   *    --------------------------------------
   *    const.alt 1             -
   *    smul                    -
   *    --------------------------------------
   *    const.pri 1             load.s.pri %1
   *    load.s.alt %1           -
   *    sdiv                    -
   *    --------------------------------------
   *    const.pri 1             load.pri %1
   *    load.alt %1             -
   *    sdiv                    -
   */
  {
    #ifdef SCPACK
      "const.alt 0!add!",
      ";!",
    #else
      "\243\223 \245\323",
      ";!",
    #endif
    2-0, 1-0
  },
  {
    #ifdef SCPACK
      "const.pri 0!load.s.alt %1!sub!",
      "load.s.pri %1!",
    #else
      "\243\203\245\235\264sub!",
      "\315",
    #endif
    3-1, 2-1
  },
  {
    #ifdef SCPACK
      "const.pri 0!load.alt %1!sub!",
      "load.pri %1!",
    #else
      "\243\203\245\216\264sub!",
      "\325",
    #endif
    3-1, 2-1
  },
  {
    #ifdef SCPACK
      "const.alt 1!smul!",
      ";!",
    #else
      "\243\223 \204smul!",
      ";!",
    #endif
    2-0, 1-0
  },
  {
    #ifdef SCPACK
      "const.pri 1!load.s.alt %1!sdiv!",
      "load.s.pri %1!",
    #else
      "\243\203\204\235\264sdiv!",
      "\315",
    #endif
    3-1, 2-1
  },
  {
    #ifdef SCPACK
      "const.pri 1!load.alt %1!sdiv!",
      "load.pri %1!",
    #else
      "\243\203\204\216\264sdiv!",
      "\325",
    #endif
    3-1, 2-1
  },
  /* For packed arrays, array access can be optimized (packed arrays
   * do not take advantage of the LIDX or IDXADDR instructions).
   *    addr.pri %1             addr.alt %1
   *    push.pri                load.s.pri %2
   *    load.s.pri %2           bounds %3
   *    bounds %3               -
   *    pop.alt                 -
   *
   * Notes (additional cases):
   * 1. instruction addr.pri can also be const.pri (for
   *    global arrays)
   * 2. the bounds instruction can be absent, but that
   *    case is already handled (see #1#)
   */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!bounds %3!pop.alt!",
      "addr.alt %1!load.s.pri %2!bounds %3!",
    #else
      "\326\344\357\263",
      "\275\352\357",
    #endif
    5-3, 3-3
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!bounds %3!pop.alt!",
      "const.alt %1!load.s.pri %2!bounds %3!",
    #else
      "\303\344\357\263",
      "\243\352\357",
    #endif
    5-3, 3-3
  },
  /* During a calculation, the intermediate result must sometimes
   * be moved from PRI to ALT, like in:
   *    push.pri                xchg
   *    load.s.pri %1           load.s.pri %1
   *    pop.alt                 -
   *
   * The above also occurs for "load.pri" and for "const.pri",
   * so add another two cases.
   */
  {
    #ifdef SCPACK
      "push.pri!load.s.pri %1!pop.alt!",
      "xchg!load.s.pri %1!",
    #else
      "\260\315\263",
      "\274\315",
    #endif
    3-2, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!load.pri %1!pop.alt!",
      "xchg!load.pri %1!",
    #else
      "\260\325\263",
      "\274\325",
    #endif
    3-2, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!const.pri %1!pop.alt!",
      "xchg!const.pri %1!",
    #else
      "\260\303\263",
      "\274\303",
    #endif
    3-2, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!zero.pri!pop.alt!",
      "xchg!zero.pri!",
    #else
      "\260\350\237\263",
      "\274\350\237",
    #endif
    3-2, 0-0
  },
  /* An even simpler PUSH/POP optimization (occurs in
   * switch statements):
   *    push.pri                xchg
   *    pop.alt                 -
   * Note that it is somewhat dangerous to do this, as
   * the original sequence keeps PRI and the new sequence
   * destroys it.
   */
  {
    #ifdef SCPACK
      "push.pri!pop.alt!",
      "xchg!",
    #else
      "\260\263",
      "\274",
    #endif
    2-1, 0-0
  },
  /* Redundant pushes (happens in some array operations)
   *    pop.alt                -
   *    push.alt               -
   */
  {
    #ifdef SCPACK
      "pop.alt!push.alt!",
      ";!",
    #else
      "\263\212\247",
      ";!",
    #endif
    2-0, 0-0
  },
  /* Some simple arithmetic sequences
   */
  {
    #ifdef SCPACK
      "xchg!load.s.pri %1!add!",
      "load.s.alt %1!add!",
    #else
      "\274\315\323",
      "\235\264\323",
    #endif
    3-2, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!load.pri %1!add!",
      "load.alt %1!add!",
    #else
      "\274\325\323",
      "\216\264\323",
    #endif
    3-2, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!const.pri %1!add!",
      "const.alt %1!add!",
    #else
      "\274\303\323",
      "\243\264\323",
    #endif
    3-2, 1-1
  },
  /* References with a default value generate new cells on the heap
   * dynamically. That code often ends with:
   *    xchg                    push.alt
   *    push.pri                -
   */
  {
    #ifdef SCPACK
      "xchg!push.pri!",
      "push.alt!",
    #else
      "\274\260",
      "\212\247",
    #endif
    2-1, 0-0
  },
  /* Test for zero (common case, especially for strings)
   * E.g. the test expression of: "for (i=0; str{i}!=0; ++i)"
   *
   *    zero.alt                jzer %1
   *    eq                      -
   *    jnz %1                  -
   *    --------------------------------------
   *    zero.alt                jnz %1
   *    eq                      -
   *    jzer %1                 -
   *    --------------------------------------
   *    zero.alt                jzer %1
   *    neq                     -
   *    jzer %1                 -
   */
  {
    #ifdef SCPACK
      "zero.alt!eq!jnz %1!",
      "jzer %1!",
    #else
      "\350\247\327jnz\214",
      "\355",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "zero.alt!eq!jzer %1!",
      "jnz %1!",
    #else
      "\350\247\327\355",
      "jnz\214",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "zero.alt!neq!jzer %1!",
      "jzer %1!",
    #else
      "\350\247n\327\355",
      "\355",
    #endif
    3-1, 1-1
  },
  /* Array comparison has a NOT instruction that can sometimes be optimized away
   *    not                     jnz %1
   *    jzer %1                 -
   *    --------------------------------------
   *    not                     jzer %1
   *    jnz %1                  -
   */
  {
    #ifdef SCPACK
      "not!jzer %1!",
      "jnz %1!",
    #else
      "not!\355",
      "jnz\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "not!jnz %1!",
      "jzer %1!",
    #else
      "not!jnz\214",
      "\355",
    #endif
    2-1, 1-1
  },

  /* Incrementing and decrementing global and local variables, and reference
   * arguments may have redundant PUSH/POP instructions, for example when the
   * primary register is altered after restoring it, or at the end of an
   * expression.
   *    push.pri                load.s.pri %1   ; reference argument
   *    load.s.pri %1           inc.i
   *    inc.i                   lref.s.pri %2
   *    pop.pri                 -
   *    lref.s.pri %2           -
   *    --------------------------------------
   *    push.pri                load.s.pri %1
   *    load.s.pri %1           inc.i
   *    inc.i                   ;$exp
   *    pop.pri                 -
   *    ;$exp                   -
   *    --------------------------------------
   *    push.pri                addr.pri %1     ; local variable
   *    addr.pri %1             inc.i
   *    inc.i                   load.s.pri %2
   *    pop.pri                 -
   *    load.s.pri %2           -
   *    --------------------------------------
   *    push.pri                const.pri %1    ; global variable
   *    const.pri %1            inc.i
   *    inc.i                   load.pri %2
   *    pop.pri                 -
   *    load.pri %2             -
   * The same is true for dec.i sequences.
   */
  {
    #ifdef SCPACK
      "push.pri!load.s.pri %1!inc.i!pop.pri!lref.s.pri %2!",
      "load.s.pri %1!inc.i!lref.s.pri %2!",
    #else
      "\260\315\312\305\364\354\244",
      "\315\312\305\354\244",
    #endif
    5-3, 2-2
  },
  {
    #ifdef SCPACK
      "push.pri!load.s.pri %1!inc.i!pop.pri!;$exp!",
      "load.s.pri %1!inc.i!;$exp!",
    #else
      "\260\315\312\305\364\257",
      "\315\312\305\257",
    #endif
    4-2, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!addr.pri %1!inc.i!pop.pri!;load.s.pri %2!",
      "addr.pri %1!inc.i!;load.s.pri %2!",
    #else
      "\260\326\312\305\364;\267",
      "\326\312\305;\267",
    #endif
    5-3, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!addr.pri %1!inc.i!pop.pri!;$exp!",
      "addr.pri %1!inc.i!;$exp!",
    #else
      "\260\326\312\305\364\257",
      "\326\312\305\257",
    #endif
    4-2, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!const.pri %1!inc.i!pop.pri!;load.pri %2!",
      "const.pri %1!inc.i!;load.pri %2!",
    #else
      "\260\303\312\305\364;\356",
      "\303\312\305;\356",
    #endif
    5-3, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!const.pri %1!inc.i!pop.pri!;$exp!",
      "const.pri %1!inc.i!;$exp!",
    #else
      "\260\303\312\305\364\257",
      "\303\312\305\257",
    #endif
    4-2, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!load.s.pri %1!dec.i!pop.pri!lref.s.pri %2!",
      "load.s.pri %1!dec.i!lref.s.pri %2!",
    #else
      "\260\315\314\305\364\354\244",
      "\315\314\305\354\244",
    #endif
    5-3, 2-2
  },
  {
    #ifdef SCPACK
      "push.pri!load.s.pri %1!dec.i!pop.pri!;$exp!",
      "load.s.pri %1!dec.i!;$exp!",
    #else
      "\260\315\314\305\364\257",
      "\315\314\305\257",
    #endif
    4-2, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!addr.pri %1!dec.i!pop.pri!;load.s.pri %2!",
      "addr.pri %1!dec.i!;load.s.pri %2!",
    #else
      "\260\326\314\305\364;\267",
      "\326\314\305;\267",
    #endif
    5-3, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!addr.pri %1!dec.i!pop.pri!;$exp!",
      "addr.pri %1!dec.i!;$exp!",
    #else
      "\260\326\314\305\364\257",
      "\326\314\305\257",
    #endif
    4-2, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!const.pri %1!dec.i!pop.pri!;load.pri %2!",
      "const.pri %1!dec.i!;load.pri %2!",
    #else
      "\260\303\314\305\364;\356",
      "\303\314\305;\356",
    #endif
    5-3, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!const.pri %1!dec.i!pop.pri!;$exp!",
      "const.pri %1!dec.i!;$exp!",
    #else
      "\260\303\314\305\364\257",
      "\303\314\305\257",
    #endif
    4-2, 1-1
  },
  /* there is a special opcode for left-shift by a constant, use it */
  {
    #ifdef SCPACK
      "const.alt %1!shl!",
      "shl.c.pri %1!",
    #else
      "\243\264\330!",
      "\341\225",
    #endif
    2-1, 1-1
  },

  /* ----------------------------------- */
  /* Supplemental and macro instructions */
  /* ----------------------------------- */

  /* separator, so optimizer can stop before generating macro opcodes */
  { separator_macro, "", 0 },

  /* Array indexing can merit from special instructions.
   * Simple indexed array lookup can be optimized quite
   * a bit.
   *    addr.pri %1             addr.alt %1
   *    push.pri                load.s.pri %2
   *    load.s.pri %2           bounds %3
   *    bounds %3               lidx.b %4
   *    shl.c.pri %4            -
   *    pop.alt                 -
   *    add                     -
   *    load.i                  -
   *
   * And to prepare for storing a value in an array
   *    addr.pri %1             addr.alt %1
   *    push.pri                load.s.pri %2
   *    load.s.pri %2           bounds %3
   *    bounds %3               idxaddr.b %4
   *    shl.c.pri %4            -
   *    pop.alt                 -
   *    add                     -
   *
   * Notes (additional cases):
   * 1. instruction addr.pri can also be const.pri (for
   *    global arrays)
   * 2. the bounds instruction can be absent
   * 3. when "%4" (the shift value) is 2 (with 32-bit cells), use the
   *    even more optimal instructions LIDX and IDDXADDR
   *
   * If the array index is more complex, one can only optimize
   * the last four instructions:
   *    shl.c.pri %1            pop.alt
   *    pop.alt                 lidx.b %1
   *    add                     -
   *    loadi                   -
   *    --------------------------------------
   *    shl.c.pri %1            pop.alt
   *    pop.alt                 idxaddr.b %1
   *    add                     -
   */
#if !defined BIT16
  /* loading from array, "cell" shifted */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri 2!pop.alt!add!load.i!",
      "addr.alt %1!load.s.pri %2!bounds %3!lidx!",
    #else
      "\326\344\357\341\203\220\360\216\305",
      "\275\352\357l\340!",
    #endif
    8-4, 4-3
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri 2!pop.alt!add!load.i!",
      "const.alt %1!load.s.pri %2!bounds %3!lidx!",
    #else
      "\303\344\357\341\203\220\360\216\305",
      "\243\352\357l\340!",
    #endif
    8-4, 4-3
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!shl.c.pri 2!pop.alt!add!load.i!",
      "addr.alt %1!load.s.pri %2!lidx!",
    #else
      "\326\344\341\203\220\360\216\305",
      "\275\352l\340!",
    #endif
    7-3, 3-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!shl.c.pri 2!pop.alt!add!load.i!",
      "const.alt %1!load.s.pri %2!lidx!",
    #else
      "\303\344\341\203\220\360\216\305",
      "\243\352l\340!",
    #endif
    7-3, 3-2
  },
#endif
  /* loading from array, not "cell" shifted */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri %4!pop.alt!add!load.i!",
      "addr.alt %1!load.s.pri %2!bounds %3!lidx.b %4!",
    #else
      "\326\344\357\341\230\310\360\216\305",
      "\275\352\357l\340.b\332",
    #endif
    8-4, 4-4
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri %4!pop.alt!add!load.i!",
      "const.alt %1!load.s.pri %2!bounds %3!lidx.b %4!",
    #else
      "\303\344\357\341\230\310\360\216\305",
      "\243\352\357l\340.b\332",
    #endif
    8-4, 4-4
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!shl.c.pri %3!pop.alt!add!load.i!",
      "addr.alt %1!load.s.pri %2!lidx.b %3!",
    #else
      "\326\344\341\2303!\360\216\305",
      "\275\352l\340.b\270",
    #endif
    7-3, 3-3
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!shl.c.pri %3!pop.alt!add!load.i!",
      "const.alt %1!load.s.pri %2!lidx.b %3!",
    #else
      "\303\344\341\2303!\360\216\305",
      "\243\352l\340.b\270",
    #endif
    7-3, 3-3
  },
#if !defined BIT16
  /* array index calculation for storing a value, "cell" aligned */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri 2!pop.alt!add!",
      "addr.alt %1!load.s.pri %2!bounds %3!idxaddr!",
    #else
      "\326\344\357\341\203\220\360",
      "\275\352\357\340\246\227",
    #endif
    7-4, 4-3
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri 2!pop.alt!add!",
      "const.alt %1!load.s.pri %2!bounds %3!idxaddr!",
    #else
      "\303\344\357\341\203\220\360",
      "\243\352\357\340\246\227",
    #endif
    7-4, 4-3
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!shl.c.pri 2!pop.alt!add!",
      "addr.alt %1!load.s.pri %2!idxaddr!",
    #else
      "\326\344\341\203\220\360",
      "\275\352\340\246\227",
    #endif
    6-3, 3-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!shl.c.pri 2!pop.alt!add!",
      "const.alt %1!load.s.pri %2!idxaddr!",
    #else
      "\303\344\341\203\220\360",
      "\243\352\340\246\227",
    #endif
    6-3, 3-2
  },
#endif
  /* array index calculation for storing a value, not "cell" packed */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri %4!pop.alt!add!",
      "addr.alt %1!load.s.pri %2!bounds %3!idxaddr.b %4!",
    #else
      "\326\344\357\341\230\310\360",
      "\275\352\357\340\275.b\332",
    #endif
    7-4, 4-4
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri %4!pop.alt!add!",
      "const.alt %1!load.s.pri %2!bounds %3!idxaddr.b %4!",
    #else
      "\303\344\357\341\230\310\360",
      "\243\352\357\340\275.b\332",
    #endif
    7-4, 4-4
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!shl.c.pri %3!pop.alt!add!",
      "addr.alt %1!load.s.pri %2!idxaddr.b %3!",
    #else
      "\326\344\341\2303!\360",
      "\275\352\340\275.b\270",
    #endif
    6-3, 3-3
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!shl.c.pri %3!pop.alt!add!",
      "const.alt %1!load.s.pri %2!idxaddr.b %3!",
    #else
      "\303\344\341\2303!\360",
      "\243\352\340\275.b\270",
    #endif
    6-3, 3-3
  },
#if !defined BIT16
  /* the shorter array indexing sequences, see above for comments */
  {
    #ifdef SCPACK
      "shl.c.pri 2!pop.alt!add!loadi!",
      "pop.alt!lidx!",
    #else
      "\341\203\220\360\216\226",
      "\263l\340!",
    #endif
    4-2, 1-0
  },
  {
    #ifdef SCPACK
      "shl.c.pri 2!pop.alt!add!",
      "pop.alt!idxaddr!",
    #else
      "\341\203\220\360",
      "\263\340\246\227",
    #endif
    3-2, 1-0
  },
#endif
  {
    #ifdef SCPACK
      "shl.c.pri %1!pop.alt!add!loadi!",
      "pop.alt!lidx.b %1!",
    #else
      "\341\225\360\216\226",
      "\263l\340.b\214",
    #endif
    4-2, 1-1
  },
  {
    #ifdef SCPACK
      "shl.c.pri %1!pop.alt!add!",
      "pop.alt!idxaddr.b %1!",
    #else
      "\341\225\360",
      "\263\340\275.b\214",
    #endif
    3-2, 1-1
  },
  /* Declaration of simple variables often follows the sequence:
   *    ;$lcl <name> <stk>      ;$lcl <name> <stk>
   *    stack -4                push.c <constval>
   *    const.pri <constval>    ;$exp
   *    stor.s <stk>            -
   *    ;$exp                   -
   */
  {
    #ifdef SCPACK
      ";$lcl %1 %2!stack -4!const.pri %3!stor.s %2!;$exp!",
      ";$lcl %1 %2!push.c %3!;$exp!",
    #else
      "\222lcl\342\231ack -\310\243\2303!\370\213\250\257",
      "\222lcl\342\212\240\270\257",
    #endif
    3-1, 3-1
  },
  {
    #ifdef SCPACK
      ";$lcl %1 %2!stack -4!zero.pri!stor.s %2!;$exp!",
      ";$lcl %1 %2!push.c #0!;$exp!",
    #else
      "\222lcl\342\231ack -\310\350\237\370\213\250\257",
      "\222lcl\342\212\240\311\245\257",
    #endif
    3-1, 2-1
  },
#if 0
  /* When variables are declared and assigned a variable, the sequence is:
   *    ;$lcl <name> <stk>      ;$lcl <name> <stk>
   *    stack -4                stack -4
   *    load.pri <addr>         load.pri <addr>
   *    stor.s <stk>            stor.i
   *    ;$exp                   ;$exp
   */
  {
    #ifdef SCPACK
      ";$lcl %1 %2!stack -4!load.pri %3!stor.s %2!;$exp!",
      ";$lcl %1 %2!stack #-4!load.pri %3!stor.i!;$exp!",
    #else
      "\222lcl\342\231ack -\310\216\2303!\370\213\250\257",
      "\222lcl\342\231ack\311-\310\216\2303!\370\305\257",
    #endif
    3-3, 3-2
  },
  {
    #ifdef SCPACK
      ";$lcl %1 %2!stack -4!load.s.pri %3!stor.s %2!;$exp!",
      ";$lcl %1 %2!stack #-4!load.s.pri %3!stor.i!;$exp!",
    #else
      "\222lcl\342\231ack -\310\235\2303!\370\213\250\257",
      "\222lcl\342\231ack\311-\310\235\2303!\370\305\257",
    #endif
    3-3, 3-2
  },
#endif
  /* simple arithmetic sequences, involving subtraction */
  {
    #ifdef SCPACK
      "xchg!load.s.pri %1!sub!",
      "load.s.alt %1!sub.inv!",
    #else
      "\274\315sub!",
      "\235\264sub.\307v!",
    #endif
    3-2, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!load.pri %1!sub!",
      "load.alt %1!sub.inv!",
    #else
      "\274\325sub!",
      "\216\264sub.\307v!",
    #endif
    3-2, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!const.pri %1!sub!",
      "const.alt %1!sub.inv!",
    #else
      "\274\303sub!",
      "\243\264sub.\307v!",
    #endif
    3-2, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!lref.s.pri %1!sub!",
      "lref.s.alt %1!sub.inv!",
    #else
      "\274\354\225sub!",
      "\354\264sub.\307v!",
    #endif
    3-2, 1-1
  },
  /* optimizing the calling of native functions (which always have a parameter
   * count pushed before, and the stack pointer restored afterwards
   */
  {
    #ifdef SCPACK
      "push.c %1!sysreq %2!stack %3!",        //note: %3 == %1 + 4
      "sysreq.n %2 %1!",
    #else
      "\212\362sysr\302\250\231ack\270",
      "sysr\302.n\333\214",
    #endif
    3-1, 3-2
  },
  /* User-defined operators first load the operands into registers and
   * then have them pushed onto the stack. This can give rise to sequences
   * like:
   *    const.pri %1            push.c %1
   *    const.alt %2            push.c %2
   *    push.pri                -
   *    push.alt                -
   * A similar sequence occurs with the two PUSH.pri/alt instructions inverted.
   * The first, second, or both CONST.pri/alt instructions can also be
   * LOAD.pri/alt.
   * This gives 2 x 4 cases.
   */
  {
    #ifdef SCPACK
      "const.pri %1!const.alt %2!push.pri!push.alt!",
      "push.c %1!push.c %2!",
    #else
      "\303\243\343\260\212\247",
      "\212\362\212\240\250",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!const.alt %2!push.alt!push.pri!",
      "push.c %2!push.c %1!",
    #else
      "\303\243\343\212\247\260",
      "\212\240\250\212\362",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!load.alt %2!push.pri!push.alt!",
      "push.c %1!push %2!",
    #else
      "\303\216\343\260\212\247",
      "\212\362\212\250",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!load.alt %2!push.alt!push.pri!",
      "push %2!push.c %1!",
    #else
      "\303\216\343\212\247\260",
      "\212\250\212\362",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!const.alt %2!push.pri!push.alt!",
      "push %1!push.c %2!",
    #else
      "\325\243\343\260\212\247",
      "\212\214\212\240\250",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!const.alt %2!push.alt!push.pri!",
      "push.c %2!push %1!",
    #else
      "\325\243\343\212\247\260",
      "\212\240\250\212\214",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!load.alt %2!push.pri!push.alt!",
      "push %1!push %2!",
    #else
      "\325\216\343\260\212\247",
      "\212\214\212\250",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!load.alt %2!push.alt!push.pri!",
      "push %2!push %1!",
    #else
      "\325\216\343\212\247\260",
      "\212\250\212\214",
    #endif
    4-2, 2-2
  },
  /* Function calls (parameters are passed on the stack)
   *    load.s.pri %1           push.s %1
   *    push.pri                -
   *    --------------------------------------
   *    load.pri %1             push %1
   *    push.pri                -
   *    --------------------------------------
   *    const.pri %1            push.c %1
   *    push.pri                -
   *    --------------------------------------
   *    zero.pri                push.c 0
   *    push.pri                -
   *    --------------------------------------
   *    addr.pri %1             push.adr %1
   *    push.pri                -
   *
   * However, PRI must not be needed after this instruction
   * if this shortcut is used. Check for the ;$par comment.
   */
  {
    #ifdef SCPACK
      "load.s.pri %1!push.pri!;$par!",
      "push.s %1!;$par!",
    #else
      "\315\260\234",
      "\212\361\234",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "load.pri %1!push.pri!;$par!",
      "push %1!;$par!",
    #else
      "\325\260\234",
      "\212\214\234",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!;$par!",
      "push.c %1!;$par!",
    #else
      "\303\260\234",
      "\212\362\234",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "zero.pri!push.pri!;$par!",
      "push.c #0!;$par!",
    #else
      "\350\237\260\234",
      "\212\240\311\245\234",
    #endif
    2-1, 0-1
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!;$par!",
      "push.adr %1!;$par!",
    #else
      "\326\260\234",
      "\212\300\214\234",
    #endif
    2-1, 1-1
  },
  /* Native function calls with parameters that must be relocated.
   * Note that global variables cannot hold an address and therefore
   * no "pushr" instruction exists (a local variable holds an address
   * if that variable is a function argument that refers to an array).
   *
   *    load.s.pri %1           pushr.s %1
   *    pushr.pri               -
   *    --------------------------------------
   *    const.pri %1            pushr.c %1
   *    pushr.pri               -
   *    --------------------------------------
   *    zero.pri                pushr.c 0
   *    pushr.pri               -
   *    --------------------------------------
   *    addr.pri %1             pushr.adr %1
   *    pushr.pri               -
   *
   * Again, PRI must not be needed after this instruction
   * if this shortcut is used. Check for the ;$par comment.
   */
  {
    #ifdef SCPACK
      "load.s.pri %1!pushr.pri!;$par!",
      "pushr.s %1!;$par!",
    #else
      "\315\253\237\234",
      "\253\361\234",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "const.pri %1!pushr.pri!;$par!",
      "pushr.c %1!;$par!",
    #else
      "\303\253\237\234",
      "\253\362\234",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "zero.pri!pushr.pri!;$par!",
      "pushr.c #0!;$par!",
    #else
      "\350\237\253\237\234",
      "\253\240\311\245\234",
    #endif
    2-1, 0-1
  },
  {
    #ifdef SCPACK
      "addr.pri %1!pushr.pri!;$par!",
      "pushr.adr %1!;$par!",
    #else
      "\326\253\237\234",
      "\253\300\214\234",
    #endif
    2-1, 1-1
  },
  /* Simple arithmetic operations on constants. Subtraction is handled in
   * a separate section, because it is not commutative.
   *    const.alt %1            add.c %1
   *    add                     -
   *    --------------------------------------
   *    const.alt %1            smul.c %1
   *    smul                    -
   *    --------------------------------------
   *    const.alt %1            eq.c.pri %1
   *    eq                      -
   */
  {
    #ifdef SCPACK
      "const.alt %1!add!",
      "add.c %1!",
    #else
      "\243\264\323",
      "\246\362",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "const.alt %1!smul!",
      "smul.c %1!",
    #else
      "\243\264smul!",
      "smul\362",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "const.alt %1!eq!",
      "eq.c.pri %1!",
    #else
      "\243\264\327",
      "\302\240\225",
    #endif
    2-1, 1-1
  },
  /* Subtraction of a constant. Note that the subtraction is converted to
   * the addition of the inverse value.
   *    const.pri %1            load.s.pri %2
   *    load.s.alt %2           add.c -%1
   *    sub                     -
   *    --------------------------------------
   *    const.pri %1            load.pri %2
   *    load.alt %2             add.c -%1
   *    sub                     -
   */
  {
    #ifdef SCPACK
      "const.pri %1!load.s.alt %2!sub!",
      "load.s.pri %2!add.c -%1!",
    #else
      "\303\235\343sub!",
      "\267\246\240 -\205",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!load.alt %2!sub!",
      "load.pri %2!add.c -%1!",
    #else
      "\303\216\343sub!",
      "\356\246\240 -\205",
    #endif
    3-2, 2-2
  },
  /* With arrays indexed with constants that come from enumerations, it happens
   * multiple add.c opcodes follow in sequence.
   *    add.c %1                add.c %1+%2
   *    add.c %2                -
   */
  {
    #ifdef SCPACK
      "add.c %1!add.c %2!",
      "add.c %1+%2!",
    #else
      "\246\362\246\240\250",
      "\246\240\265+%\220",
    #endif
    2-1, 2-1
  },
  /* Compare and jump in chained and non-chained relation expressions.
   * The exchange operation may be removed on relation operators
   * by selecting the inverse relational operator
   *    xchg                    jsgeq  %1   also for sless, sgeq and sleq
   *    sgrtr                   ;$exp       (occurs for non-chained comparisons)
   *    jzer %1                 -
   *    ;$exp                   -
   *    --------------------------------------
   *    xchg                    sless       also for sless, sgeq and sleq
   *    sgrtr                   ;$exp       (occurs for non-chained comparisons)
   *    ;$exp                   -
   */
  {
    #ifdef SCPACK
      "xchg!sgrtr!jzer %1!;$exp!",
      "jsgeq %1!;$exp!",
    #else
      "\274\336rt\227\334\317",
      "j\336\302\317",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!sless!jzer %1!;$exp!",
      "jsleq %1!;$exp!",
    #else
      "\274\337ess!\334\317",
      "j\337\302\317",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!sgeq!jzer %1!;$exp!",
      "jsgrtr %1!;$exp!",
    #else
      "\274\336\327\334\317",
      "j\336rtr\317",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!sleq!jzer %1!;$exp!",
      "jsless %1!;$exp!",
    #else
      "\274\337\327\334\317",
      "j\337ess\317",
    #endif
    3-1, 1-1
  },
  /* Standard compare and jump
   *    eq                      jneq %1
   *    jzer %1                 -
   *    --------------------------------------
   *    eq                      jeq %1
   *    jnz %1                  -
   *    --------------------------------------
   *    neq                     jeq %1
   *    jzer %1                 -
   *    --------------------------------------
   *    neq                     jneq %1
   *    jnz %1                  -
   * An similarly for other relations
   *    sless                   jsgeq %1
   *    jzer %1                 -
   *    --------------------------------------
   *    sless                   jsless %1
   *    jnz %1                  -
   *    --------------------------------------
   *    sleq                    jsgrtr %1
   *    jzer %1                 -
   *    --------------------------------------
   *    sleq                    jsleq %1
   *    jnz %1                  -
   *    --------------------------------------
   *    sgrtr                   jsleq %1
   *    jzer %1                 -
   *    --------------------------------------
   *    sgrtr                   jsgrtr %1
   *    jnz %1                  -
   *    --------------------------------------
   *    sgeq                    jsless %1
   *    jzer %1                 -
   *    --------------------------------------
   *    sgeq                    jsgeq %1
   *    jnz %1                  -
   * We can relax the optimizations for the unsigned comparisons,
   * because the Pawn compiler currently only generates signed
   * comparisons.
   */
  {
    #ifdef SCPACK
      "eq!jzer %1!",
      "jneq %1!",
    #else
      "\327\355",
      "jn\302\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "eq!jnz %1!",
      "jeq %1!",
    #else
      "\327jnz\214",
      "j\302\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "neq!jzer %1!",
      "jeq %1!",
    #else
      "n\327\355",
      "j\302\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "neq!jnz %1!",
      "jneq %1!",
    #else
      "n\327jnz\214",
      "jn\302\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "sless!jzer %1!",
      "jsgeq %1!",
    #else
      "\337ess!\355",
      "j\336\302\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "sless!jnz %1!",
      "jsless %1!",
    #else
      "\337ess!jnz\214",
      "j\337ess\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "sleq!jzer %1!",
      "jsgrtr %1!",
    #else
      "\337\327\355",
      "j\336rtr\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "sleq!jnz %1!",
      "jsleq %1!",
    #else
      "\337\327jnz\214",
      "j\337\302\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "sgrtr!jzer %1!",
      "jsleq %1!",
    #else
      "\336rt\227\355",
      "j\337\302\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "sgrtr!jnz %1!",
      "jsgrtr %1!",
    #else
      "\336rt\227jnz\214",
      "j\336rtr\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "sgeq!jzer %1!",
      "jsless %1!",
    #else
      "\336\327\355",
      "j\337ess\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "sgeq!jnz %1!",
      "jsgeq %1!",
    #else
      "\336\327jnz\214",
      "j\336\302\214",
    #endif
    2-1, 1-1
  },
  /* select more appropriate INC and DEC opcodes
   *    addr.pri %1             inc.s %1
   *    inc.i                   -
   *    --------------------------------------
   *    const.pri %1            inc %1
   *    inc.i                   -
   * and the same for DEC
   */
  {
    #ifdef SCPACK
      "addr.pri %1!inc.i!",
      "inc.s %1!",
    #else
      "\326\312\305",
      "\312\361",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "const.pri %1!inc.i!",
      "inc %1!",
    #else
      "\303\312\305",
      "\312\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "addr.pri %1!dec.i!",
      "dec.s %1!",
    #else
      "\326\314\305",
      "\314\361",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "const.pri %1!dec.i!",
      "dec %1!",
    #else
      "\303\314\305",
      "\314\214",
    #endif
    2-1, 1-1
  },
  /* remove redundant PUSH/POP around an increment, if these
   * are (still) present
   *    push.pri                inc.s %1
   *    inc.s %1                -
   *    pop.pri                 -
   *    --------------------------------------
   *    push.pri                inc %1
   *    inc %1                  -
   *    pop.pri                 -
   * and the same for DEC
   */
  {
    #ifdef SCPACK
      "push.pri %1!inc.s %1!pop.pri!",
      "inc.s %1!",
    #else
      "\212\225\312\361\364",
      "\312\361",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri %1!inc %1!pop.pri!",
      "inc %1!",
    #else
      "\212\225\312\214\364",
      "\312\214",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri %1!dec.s %1!pop.pri!",
      "dec.s %1!",
    #else
      "\212\225\314\361\364",
      "\314\361",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri %1!dec %1!pop.pri!",
      "dec %1!",
    #else
      "\212\225\314\214\364",
      "\314\214",
    #endif
    3-1, 1-1
  },
  /* Incrementing and decrementing leaves a value in
   * in PRI which may not be used (for example, as the
   * third expression in a "for" loop).
   *    inc %1                  inc %1  ; ++n
   *    load.pri %1             ;$exp
   *    ;$exp                   -
   *    --------------------------------------
   *    load.pri %1             inc %1  ; n++, e.g. "for (n=0; n<10; n++)"
   *    inc %1                  ;$exp
   *    ;$exp                   -
   * Plus the varieties for stack relative increments
   * and decrements.
   */
  {
    #ifdef SCPACK
      "inc %1!load.pri %1!;$exp!",
      "inc %1!;$exp!",
    #else
      "\312\214\325\257",
      "\312\317",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "load.pri %1!inc %1!;$exp!",
      "inc %1!;$exp!",
    #else
      "\325\312\317",
      "\312\317",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "inc.s %1!load.s.pri %1!;$exp!",
      "inc.s %1!;$exp!",
    #else
      "\312\361\315\257",
      "\312\213\317",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!inc.s %1!;$exp!",
      "inc.s %1!;$exp!",
    #else
      "\315\312\213\317",
      "\312\213\317",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "dec %1!load.pri %1!;$exp!",
      "dec %1!;$exp!",
    #else
      "\314\214\325\257",
      "\314\317",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "load.pri %1!dec %1!;$exp!",
      "dec %1!;$exp!",
    #else
      "\325\314\317",
      "\314\317",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "dec.s %1!load.s.pri %1!;$exp!",
      "dec.s %1!;$exp!",
    #else
      "\314\361\315\257",
      "\314\213\317",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!dec.s %1!;$exp!",
      "dec.s %1!;$exp!",
    #else
      "\315\314\213\317",
      "\314\213\317",
    #endif
    2-1, 2-1
  },
  /* Loading the constant zero has a special opcode.
   * When storing zero in memory, the value of PRI must not be later on.
   *    const.pri 0             zero %1
   *    stor %1                 ;$exp
   *    ;$exp                   -
   *    --------------------------------------
   *    const.pri 0             zero.s %1
   *    stor.s %1               ;$exp
   *    ;$exp                   -
   *    --------------------------------------
   *    zero.pri                zero %1
   *    stor %1                 ;$exp
   *    ;$exp                   -
   *    --------------------------------------
   *    zero.pri                zero.s %1
   *    stor.s %1               ;$exp
   *    ;$exp                   -
   *    --------------------------------------
   *    const.pri 0             zero.pri
   *    --------------------------------------
   *    const.alt 0             zero.alt
   * The last two alternatives save more memory than they save
   * time, but anyway...
   */
  {
    #ifdef SCPACK
      "const.pri 0!stor %1!;$exp!",
      "zero %1!;$exp!",
    #else
      "\243\203\245\370\317",
      "\350\317",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "const.pri 0!stor.s %1!;$exp!",
      "zero.s %1!;$exp!",
    #else
      "\243\203\245\370\213\317",
      "\350\213\317",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "zero.pri!stor %1!;$exp!",
      "zero %1!;$exp!",
    #else
      "\350\237\370\317",
      "\350\317",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "zero.pri!stor.s %1!;$exp!",
      "zero.s %1!;$exp!",
    #else
      "\350\237\370\213\317",
      "\350\213\317",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "const.pri +0!",
      "zero.pri!",
    #else
      "\243\203+\245",
      "\350\237",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "const.alt +0!",
      "zero.alt!",
    #else
      "\243\223 +\245",
      "\350\247",
    #endif
    1-1, 1-0
  },
  /* ----- */
  /* Functions with many parameters with the same "type" have sequences like:
   *    push.c %1               pushm.c 3 %1 %2 %3
   *    ;$par                   ;$par
   *    push.c %2               -
   *    ;$par                   -
   *    push.c %3               -
   *    ;$par                   -
   *    etc.                    etc.
   *
   * Similar sequences occur with PUSH, PUSH.s and PUSHADDR, plus
   * PUSHR.c, PUSHR.s and PUSHR.adr
   */
  {
    #ifdef SCPACK
      "push.c %1!;$par!push.c %2!;$par!push.c %3!;$par!push.c %4!;$par!push.c %5!;$par!",
      "pushm.c #5 %1 %2 %3 %4 %5!",
    #else
      "\212\362\304\240\250\304\240\270\304\240\332\304\240\206\322\234",
      "\331\240\3115\374\2064\206\322",
    #endif
    5-1, 5-6
  },
  {
    #ifdef SCPACK
      "push.c %1!;$par!push.c %2!;$par!push.c %3!;$par!push.c %4!;$par!",
      "pushm.c #4 %1 %2 %3 %4!",
    #else
      "\212\362\304\240\250\304\240\270\304\240\332\234",
      "\331\240\3114\374\332",
    #endif
    4-1, 4-5
  },
  {
    #ifdef SCPACK
      "push.c %1!;$par!push.c %2!;$par!push.c %3!;$par!",
      "pushm.c #3 %1 %2 %3!",
    #else
      "\212\362\304\240\250\304\240\270\234",
      "\331\240\3113\353\270",
    #endif
    3-1, 3-4
  },
  {
    #ifdef SCPACK
      "push.c %1!;$par!push.c %2!;$par!",
      "pushm.c #2 %1 %2!",
    #else
      "\212\362\304\240\250\234",
      "\331\240\3112\342",
    #endif
    2-1, 2-3
  },
  /* ----- */
  {
    #ifdef SCPACK
      "push %1!;$par!push %2!;$par!push %3!;$par!push %4!;$par!push %5!;$par!",
      "pushm #5 %1 %2 %3 %4 %5!",
    #else
      "\212\214\304\250\304\270\304\332\304\206\322\234",
      "\331\3115\374\2064\206\322",
    #endif
    5-1, 5-6
  },
  {
    #ifdef SCPACK
      "push %1!;$par!push %2!;$par!push %3!;$par!push %4!;$par!",
      "pushm #4 %1 %2 %3 %4!",
    #else
      "\212\214\304\250\304\270\304\332\234",
      "\331\3114\374\332",
    #endif
    4-1, 4-5
  },
  {
    #ifdef SCPACK
      "push %1!;$par!push %2!;$par!push %3!;$par!",
      "pushm #3 %1 %2 %3!",
    #else
      "\212\214\304\250\304\270\234",
      "\331\3113\353\270",
    #endif
    3-1, 3-4
  },
  {
    #ifdef SCPACK
      "push %1!;$par!push %2!;$par!",
      "pushm #2 %1 %2!",
    #else
      "\212\214\304\250\234",
      "\331\3112\342",
    #endif
    2-1, 2-3
  },
  /* ----- */
  {
    #ifdef SCPACK
      "push.s %1!;$par!push.s %2!;$par!push.s %3!;$par!push.s %4!;$par!push.s %5!;$par!",
      "pushm.s #5 %1 %2 %3 %4 %5!",
    #else
      "\212\361\304\213\250\304\213\270\304\213\332\304\213\206\322\234",
      "\331\213\3115\374\2064\206\322",
    #endif
    5-1, 5-6
  },
  {
    #ifdef SCPACK
      "push.s %1!;$par!push.s %2!;$par!push.s %3!;$par!push.s %4!;$par!",
      "pushm.s #4 %1 %2 %3 %4!",
    #else
      "\212\361\304\213\250\304\213\270\304\213\332\234",
      "\331\213\3114\374\332",
    #endif
    4-1, 4-5
  },
  {
    #ifdef SCPACK
      "push.s %1!;$par!push.s %2!;$par!push.s %3!;$par!",
      "pushm.s #3 %1 %2 %3!",
    #else
      "\212\361\304\213\250\304\213\270\234",
      "\331\213\3113\353\270",
    #endif
    3-1, 3-4
  },
  {
    #ifdef SCPACK
      "push.s %1!;$par!push.s %2!;$par!",
      "pushm.s #2 %1 %2!",
    #else
      "\212\361\304\213\250\234",
      "\331\213\3112\342",
    #endif
    2-1, 2-3
  },
  /* ----- */
  {
    #ifdef SCPACK
      "push.adr %1!;$par!push.adr %2!;$par!push.adr %3!;$par!push.adr %4!;$par!push.adr %5!;$par!",
      "pushm.adr #5 %1 %2 %3 %4 %5!",
    #else
      "\212\300\214\304\300\250\304\300\270\304\300\332\304\300\206\322\234",
      "\331\300\3115\374\2064\206\322",
    #endif
    5-1, 5-6
  },
  {
    #ifdef SCPACK
      "push.adr %1!;$par!push.adr %2!;$par!push.adr %3!;$par!push.adr %4!;$par!",
      "pushm.adr #4 %1 %2 %3 %4!",
    #else
      "\212\300\214\304\300\250\304\300\270\304\300\332\234",
      "\331\300\3114\374\332",
    #endif
    4-1, 4-5
  },
  {
    #ifdef SCPACK
      "push.adr %1!;$par!push.adr %2!;$par!push.adr %3!;$par!",
      "pushm.adr #3 %1 %2 %3!",
    #else
      "\212\300\214\304\300\250\304\300\270\234",
      "\331\300\3113\353\270",
    #endif
    3-1, 3-4
  },
  {
    #ifdef SCPACK
      "push.adr %1!;$par!push.adr %2!;$par!",
      "pushm.adr #2 %1 %2!",
    #else
      "\212\300\214\304\300\250\234",
      "\331\300\3112\342",
    #endif
    2-1, 2-3
  },
  /* ----- */
  {
    #ifdef SCPACK
      "pushr.c %1!;$par!pushr.c %2!;$par!pushr.c %3!;$par!pushr.c %4!;$par!pushr.c %5!;$par!",
      "pushrm.c #5 %1 %2 %3 %4 %5!",
    #else
      "\253\362\316\240\250\316\240\270\316\240\332\316\240\206\322\234",
      "\363\240\3115\374\2064\206\322",
    #endif
    5-1, 5-6
  },
  {
    #ifdef SCPACK
      "pushr.c %1!;$par!pushr.c %2!;$par!pushr.c %3!;$par!pushr.c %4!;$par!",
      "pushrm.c #4 %1 %2 %3 %4!",
    #else
      "\253\362\316\240\250\316\240\270\316\240\332\234",
      "\363\240\3114\374\332",
    #endif
    4-1, 4-5
  },
  {
    #ifdef SCPACK
      "pushr.c %1!;$par!pushr.c %2!;$par!pushr.c %3!;$par!",
      "pushrm.c #3 %1 %2 %3!",
    #else
      "\253\362\316\240\250\316\240\270\234",
      "\363\240\3113\353\270",
    #endif
    3-1, 3-4
  },
  {
    #ifdef SCPACK
      "pushr.c %1!;$par!pushr.c %2!;$par!",
      "pushrm.c #2 %1 %2!",
    #else
      "\253\362\316\240\250\234",
      "\363\240\3112\342",
    #endif
    2-1, 2-3
  },
  /* ----- */
  {
    #ifdef SCPACK
      "pushr.s %1!;$par!pushr.s %2!;$par!pushr.s %3!;$par!pushr.s %4!;$par!pushr.s %5!;$par!",
      "pushrm.s #5 %1 %2 %3 %4 %5!",
    #else
      "\253\361\316\213\250\316\213\270\316\213\332\316\213\206\322\234",
      "\363\213\3115\374\2064\206\322",
    #endif
    5-1, 5-6
  },
  {
    #ifdef SCPACK
      "pushr.s %1!;$par!pushr.s %2!;$par!pushr.s %3!;$par!pushr.s %4!;$par!",
      "pushrm.s #4 %1 %2 %3 %4!",
    #else
      "\253\361\316\213\250\316\213\270\316\213\332\234",
      "\363\213\3114\374\332",
    #endif
    4-1, 4-5
  },
  {
    #ifdef SCPACK
      "pushr.s %1!;$par!pushr.s %2!;$par!pushr.s %3!;$par!",
      "pushrm.s #3 %1 %2 %3!",
    #else
      "\253\361\316\213\250\316\213\270\234",
      "\363\213\3113\353\270",
    #endif
    3-1, 3-4
  },
  {
    #ifdef SCPACK
      "pushr.s %1!;$par!pushr.s %2!;$par!",
      "pushrm.s #2 %1 %2!",
    #else
      "\253\361\316\213\250\234",
      "\363\213\3112\342",
    #endif
    2-1, 2-3
  },
  /* ----- */
  {
    #ifdef SCPACK
      "pushr.adr %1!;$par!pushr.adr %2!;$par!pushr.adr %3!;$par!pushr.adr %4!;$par!pushr.adr %5!;$par!",
      "pushrm.adr #5 %1 %2 %3 %4 %5!",
    #else
      "\253\300\214\316\300\250\316\300\270\316\300\332\316\300\206\322\234",
      "\363\300\3115\374\2064\206\322",
    #endif
    5-1, 5-6
  },
  {
    #ifdef SCPACK
      "pushr.adr %1!;$par!pushr.adr %2!;$par!pushr.adr %3!;$par!pushr.adr %4!;$par!",
      "pushrm.adr #4 %1 %2 %3 %4!",
    #else
      "\253\300\214\316\300\250\316\300\270\316\300\332\234",
      "\363\300\3114\374\332",
    #endif
    4-1, 4-5
  },
  {
    #ifdef SCPACK
      "pushr.adr %1!;$par!pushr.adr %2!;$par!pushr.adr %3!;$par!",
      "pushrm.adr #3 %1 %2 %3!",
    #else
      "\253\300\214\316\300\250\316\300\270\234",
      "\363\300\3113\353\270",
    #endif
    3-1, 3-4
  },
  {
    #ifdef SCPACK
      "pushr.adr %1!;$par!pushr.adr %2!;$par!",
      "pushrm.adr #2 %1 %2!",
    #else
      "\253\300\214\316\300\250\234",
      "\363\300\3112\342",
    #endif
    2-1, 2-3
  },
  /* Loading two registers at a time
   *    load.pri %1             load2 %1 %2
   *    load.alt %2             -
   *    --------------------------------------
   *    load.alt %2             load2 %1 %2
   *    load.pri %1             -
   *    --------------------------------------
   *    load.s.pri %1           load2.s %1 %2
   *    load.s.alt %2           -
   *    --------------------------------------
   *    load.s.alt %2           load2.s %1 %2
   *    load.s.pri %1           -
   */
  {
    #ifdef SCPACK
      "load.pri %1!load.alt %2!",
      "load2 %1 %2!",
    #else
      "\325\216\343",
      "\2162\342",
    #endif
    2-1, 2-2
  },
  {
    #ifdef SCPACK
      "load.alt %2!load.pri %1!",
      "load2 %1 %2!",
    #else
      "\216\343\325",
      "\2162\342",
    #endif
    2-1, 2-2
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!load.s.alt %2!",
      "load2.s %1 %2!",
    #else
      "\315\235\343",
      "\2162\213\342",
    #endif
    2-1, 2-2
  },
  {
    #ifdef SCPACK
      "load.s.alt %2!load.s.pri %1!",
      "load2.s %1 %2!",
    #else
      "\235\343\315",
      "\2162\213\342",
    #endif
    2-1, 2-2
  },
  /* Loading two registers and then pushing them occurs with user operators
   *    load2 %1 %2            pushm 2 %1 %2
   *    push.pri                -
   *    push.alt                -
   *    --------------------------------------
   *    load2.s %1 %2          pushm.s 2 %1 %2
   *    push.pri                -
   *    push.alt                -
   */
  {
    #ifdef SCPACK
      "load2 %1 %2!push.pri!push.alt!",
      "pushm #2 %1 %2!",
    #else
      "\2162\342\260\212\247",
      "\331\3112\342",
    #endif
    3-1, 2-3
  },
  {
    #ifdef SCPACK
      "load2.s %1 %2!push.pri!push.alt!",
      "pushm.s #2 %1 %2!",
    #else
      "\2162\213\342\260\212\247",
      "\331\213\3112\342",
    #endif
    3-1, 2-3
  },
  /* Load a constant in a variable
   *    const.pri %1            const %2 %1
   *    stor %2                 ;$exp
   *    ;$exp                   -
   *    --------------------------------------
   *    const.pri %1            const.s %2 %1
   *    stor.s %2               ;$exp
   *    ;$exp                   -
   */
  {
    #ifdef SCPACK
      "const.pri %1!stor %2!;$exp!",
      "const %2 %1!;$exp!",
    #else
      "\303\370\250\257",
      "\243\333\317",
    #endif
    2-1, 2-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!stor.s %2!;$exp!",
      "const.s %2 %1!;$exp!",
    #else
      "\303\370\213\250\257",
      "\243\213\333\317",
    #endif
    2-1, 2-2
  },


  /* ------------------ */
  /* Packed opcodes     */
  /* ------------------ */

  /* separator, so optimizer can stop before generating macro opcodes */
  { separator_full, "", 0 },

  /* If %0 is in the range cell_min .. cell_max, do conversions like:
   *    add.c %0                add.p.c %0
   *
   * Rules in this section may only use %0 (a special symbol which matches
   * a numeric cell in a restricted range and replaces it with a shorter
   * representation of the same value).
   */

  {
    #ifdef SCPACK
      "load.pri %0!",
      "load.p.pri %0!",
    #else
      "\216\366",
      "\216\224\366",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "load.alt %0!",
      "load.p.alt %0!",
    #else
      "\216\223\261",
      "\216\224\223\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "load.s.pri %0!",
      "load.p.s.pri %0!",
    #else
      "\235\366",
      "\216\224\213\366",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "load.s.alt %0!",
      "load.p.s.alt %0!",
    #else
      "\235\223\261",
      "\216\224\213\223\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "lref.s.pri %0!",
      "lref.p.s.pri %0!",
    #else
      "\354\366",
      "\324\224\213\366",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "lref.s.alt %0!",
      "lref.p.s.alt %0!",
    #else
      "\354\223\261",
      "\324\224\213\223\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "lodb.i %0!",
      "lodb.p.i %0!",
    #else
      "\215db.\200%\245",
      "\215db\224.\200%\245",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "const.pri %0!",
      "const.p.pri %0!",
    #else
      "\243\366",
      "\243\224\366",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "const.alt %0!",
      "const.p.alt %0!",
    #else
      "\243\223\261",
      "\243\224\223\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "addr.pri %0!",
      "addr.p.pri %0!",
    #else
      "\275\366",
      "\275\224\366",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "addr.alt %0!",
      "addr.p.alt %0!",
    #else
      "\275\223\261",
      "\275\224\223\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "stor %0!",
      "stor.p %0!",
    #else
      "\370\261",
      "\370\224\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "stor.s %0!",
      "stor.p.s %0!",
    #else
      "\370\213\261",
      "\370\224\213\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "sref.s %0!",
      "sref.p.s %0!",
    #else
      "s\321\213\261",
      "s\321\224\213\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "strb.i %0!",
      "strb.p.i %0!",
    #else
      "\231rb.\200%\245",
      "\231rb\224.\200%\245",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "lidx.b %0!",
      "lidx.p.b %0!",
    #else
      "l\340.b\261",
      "l\340\224.b\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "idxaddr.b %0!",
      "idxaddr.p.b %0!",
    #else
      "\340\275.b\261",
      "\340\275\224.b\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "align.pri %0!",
      "align.p.pri %0!",
    #else
      "\217ign\366",
      "\217ign\224\366",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "push.c %0!",
      "push.p.c %0!",
    #else
      "\212\240\261",
      "\212\224\240\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "push %0!",
      "push.p %0!",
    #else
      "\212\261",
      "\212\224\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "push.s %0!",
      "push.p.s %0!",
    #else
      "\212\213\261",
      "\212\224\213\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "push.adr %0!",
      "push.p.adr %0!",
    #else
      "\212\300\261",
      "\212\224\300\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushr.c %0!",
      "pushr.p.c %0!",
    #else
      "\253\240\261",
      "\253\224\240\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushr.s %0!",
      "pushr.p.s %0!",
    #else
      "\253\213\261",
      "\253\224\213\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushr.adr %0!",
      "pushr.p.adr %0!",
    #else
      "\253\300\261",
      "\253\224\300\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushm.c %0 %1~%2~%3~%4~%5!",
      "pushm.p.c %0 %1~%2~%3~%4~%5!",
    #else
      "\331\240\376\265\373\375\2664\266\322",
      "\331\224\240\376\265\373\375\2664\266\322",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushm %0 %1~%2~%3~%4~%5!",
      "pushm.p %0 %1~%2~%3~%4~%5!",
    #else
      "\331\376\265\373\375\2664\266\322",
      "\331\224\376\265\373\375\2664\266\322",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushm.s %0 %1~%2~%3~%4~%5!",
      "pushm.p.s %0 %1~%2~%3~%4~%5!",
    #else
      "\331\213\376\265\373\375\2664\266\322",
      "\331\224\213\376\265\373\375\2664\266\322",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushm.adr %0 %1~%2~%3~%4~%5!",
      "pushm.p.adr %0 %1~%2~%3~%4~%5!",
    #else
      "\331\300\376\265\373\375\2664\266\322",
      "\331\224\300\376\265\373\375\2664\266\322",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushrm.c %0 %1~%2~%3~%4~%5!",
      "pushrm.p.c %0 %1~%2~%3~%4~%5!",
    #else
      "\363\240\376\265\373\375\2664\266\322",
      "\363\224\240\376\265\373\375\2664\266\322",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushrm.s %0 %1~%2~%3~%4~%5!",
      "pushrm.p.s %0 %1~%2~%3~%4~%5!",
    #else
      "\363\213\376\265\373\375\2664\266\322",
      "\363\224\213\376\265\373\375\2664\266\322",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushrm.adr %0 %1~%2~%3~%4~%5!",
      "pushrm.p.adr %0 %1~%2~%3~%4~%5!",
    #else
      "\363\300\376\265\373\375\2664\266\322",
      "\363\224\300\376\265\373\375\2664\266\322",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "stack %0!",
      "stack.p %0!",
    #else
      "\231ack\261",
      "\231ack\224\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "heap %0!",
      "heap.p %0!",
    #else
      "heap\261",
      "heap\224\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "shl.c.pri %0!",
      "shl.p.c.pri %0!",
    #else
      "\341\366",
      "\330\224\240\366",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "shl.c.alt %0!",
      "shl.p.c.alt %0!",
    #else
      "\341\223\261",
      "\330\224\240\223\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "add.c %0!",
      "add.p.c %0!",
    #else
      "\246\240\261",
      "\246\224\240\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "smul.c %0!",
      "smul.p.c %0!",
    #else
      "smul\240\261",
      "smul\224\240\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "zero %0!",
      "zero.p %0!",
    #else
      "\350\261",
      "\350\224\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "zero.s %0!",
      "zero.p.s %0!",
    #else
      "\350\213\261",
      "\350\224\213\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "eq.c.pri %0!",
      "eq.p.c.pri %0!",
    #else
      "\302\240\366",
      "\302\224\240\366",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "eq.c.alt %0!",
      "eq.p.c.alt %0!",
    #else
      "\302\240\223\261",
      "\302\224\240\223\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "inc %0!",
      "inc.p %0!",
    #else
      "\312\261",
      "\312\224\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "inc.s %0!",
      "inc.p.s %0!",
    #else
      "\312\213\261",
      "\312\224\213\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "dec %0!",
      "dec.p %0!",
    #else
      "\314\261",
      "\314\224\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "dec.s %0!",
      "dec.p.s %0!",
    #else
      "\314\213\261",
      "\314\224\213\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "movs %0!",
      "movs.p %0!",
    #else
      "movs\261",
      "movs\224\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "cmps %0!",
      "cmps.p %0!",
    #else
      "cmps\261",
      "cmps\224\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "fill %0!",
      "fill.p %0!",
    #else
      "fill\261",
      "fill\224\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "halt %0!",
      "halt.p %0!",
    #else
      "h\221\261",
      "h\221\224\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "bounds %0!",
      "bounds.p %0!",
    #else
      "\351\261",
      "\351\224\261",
    #endif
    1-1, 1-0
  },

  /* ----- */
  { NULL, NULL, 0 }
};
